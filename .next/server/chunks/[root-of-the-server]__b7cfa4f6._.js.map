{"version":3,"sources":["../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../src/app/api/posts/route.ts","../../../src/utils/%E8%BF%9D%E7%A6%81%E8%AF%8D%E6%A3%80%E6%B5%8B.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/posts/route\",\n        pathname: \"/api/posts\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/posts/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/posts/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { NextResponse } from 'next/server';\nimport mysql from 'mysql2/promise';\nimport { detectSensitiveWords, hasSensitiveWords } from '../../../utils/违禁词检测';\n\n// 创建数据库连接\nasync function createConnection() {\n  return mysql.createConnection({\n    host: 'localhost',\n    port: 3306,\n    user: 'root',\n    password: '123456',\n    database: 'yueblog'\n  });\n}\n\n// 获取所有文章\nexport async function GET() {\n  try {\n    const connection = await createConnection();\n    const [rows] = await connection.execute(\n      `SELECT \n        p.id, p.title, p.excerpt, p.content, p.image, p.readTime, \n        p.authorId, p.categoryId, p.createdAt, p.updatedAt, p.status,\n        p.foundSensitiveWords, p.reviewedBy, p.reviewedAt, p.rejectionReason,\n        u.name as authorName, u.avatar as authorAvatar,\n        c.name as categoryName, c.slug as categorySlug\n      FROM post p\n      LEFT JOIN user u ON p.authorId = u.id\n      LEFT JOIN category c ON p.categoryId = c.id\n      ORDER BY p.createdAt DESC`\n    );\n    await connection.end();\n    \n    // 转换数据格式\n    const posts = (rows as any[]).map(post => ({\n      id: post.id,\n      title: post.title,\n      excerpt: post.excerpt,\n      content: post.content,\n      image: post.image,\n      readTime: post.readTime,\n      authorId: post.authorId,\n      categoryId: post.categoryId,\n      createdAt: post.createdAt,\n      updatedAt: post.updatedAt,\n      status: post.status as 'published' | 'pending' | 'rejected',\n      foundSensitiveWords: post.foundSensitiveWords ? JSON.parse(post.foundSensitiveWords) : [],\n      reviewedBy: post.reviewedBy,\n      reviewedAt: post.reviewedAt,\n      rejectionReason: post.rejectionReason,\n      likes: 0, // 添加点赞数默认值\n      author: {\n        id: post.authorId,\n        name: post.authorName,\n        avatar: post.authorAvatar\n      },\n      category: {\n        id: post.categoryId,\n        name: post.categoryName,\n        slug: post.categorySlug\n      },\n      comments: []\n    }));\n    \n    return NextResponse.json(posts, { status: 200 });\n  } catch (error) {\n    console.error('获取文章数据失败:', error);\n    return NextResponse.json({ error: '获取文章数据失败' }, { status: 500 });\n  }\n}\n\n// 创建新文章\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { title, excerpt, content, categoryId, image, authorId, readTime } = body;\n\n    // 检测违禁词\n    const allText = `${title} ${excerpt} ${content}`;\n    const foundWords = detectSensitiveWords(allText);\n    const hasSensitive = hasSensitiveWords(allText);\n    \n    // 根据敏感词检测结果设置文章状态\n    const status = hasSensitive ? 'pending' : 'published';\n\n    const connection = await createConnection();\n    const now = new Date();\n    const [result] = await connection.execute(\n      `INSERT INTO post (title, excerpt, content, categoryId, image, authorId, readTime, status, foundSensitiveWords, createdAt, updatedAt) \n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n      [title, excerpt, content, categoryId, image || null, authorId, readTime || null, status, JSON.stringify(foundWords), now, now]\n    );\n    \n    // 获取新创建的文章\n    const [newPostRows] = await connection.execute(\n      `SELECT \n        p.id, p.title, p.excerpt, p.content, p.image, p.readTime, \n        p.authorId, p.categoryId, p.status, p.foundSensitiveWords, p.createdAt, p.updatedAt,\n        u.name as authorName, u.avatar as authorAvatar,\n        c.name as categoryName, c.slug as categorySlug\n      FROM post p\n      LEFT JOIN user u ON p.authorId = u.id\n      LEFT JOIN category c ON p.categoryId = c.id\n      WHERE p.id = ?`,\n      [(result as any).insertId]\n    );\n    \n    await connection.end();\n    \n    const newPost = (newPostRows as any)[0];\n    \n    // 转换数据格式\n    const formattedPost = {\n      id: newPost.id,\n      title: newPost.title,\n      excerpt: newPost.excerpt,\n      content: newPost.content,\n      image: newPost.image,\n      readTime: newPost.readTime,\n      authorId: newPost.authorId,\n      categoryId: newPost.categoryId,\n      createdAt: newPost.createdAt,\n      updatedAt: newPost.updatedAt,\n      status: newPost.status as 'published' | 'pending' | 'rejected',\n      foundSensitiveWords: newPost.foundSensitiveWords ? JSON.parse(newPost.foundSensitiveWords) : [],\n      reviewedBy: null,\n      reviewedAt: null,\n      rejectionReason: null,\n      author: {\n        id: newPost.authorId,\n        name: newPost.authorName,\n        avatar: newPost.authorAvatar\n      },\n      category: {\n        id: newPost.categoryId,\n        name: newPost.categoryName,\n        slug: newPost.categorySlug\n      },\n      comments: []\n    };\n    \n    return NextResponse.json(formattedPost, { status: 201 });\n  } catch (error) {\n    console.error('创建文章失败:', error);\n    return NextResponse.json({ error: '创建文章失败' }, { status: 500 });\n  }\n}\n\n// 更新文章状态（审核功能）\nexport async function PUT(request: Request) {\n  try {\n    const body = await request.json();\n    const { id, status, reviewedBy, rejectionReason } = body;\n\n    if (!id || !status || !reviewedBy) {\n      return NextResponse.json({ error: '缺少必要参数' }, { status: 400 });\n    }\n\n    const connection = await createConnection();\n    const now = new Date();\n    \n    // 根据状态更新文章\n    let query = '';\n    let params: any[] = [];\n    \n    if (status === 'published') {\n      // 审核通过\n      query = `UPDATE post SET status = ?, reviewedBy = ?, reviewedAt = ?, rejectionReason = NULL, updatedAt = ? WHERE id = ?`;\n      params = [status, reviewedBy, now, now, id];\n    } else if (status === 'rejected') {\n      // 审核不通过\n      if (!rejectionReason) {\n        return NextResponse.json({ error: '拒绝原因不能为空' }, { status: 400 });\n      }\n      query = `UPDATE post SET status = ?, reviewedBy = ?, reviewedAt = ?, rejectionReason = ?, updatedAt = ? WHERE id = ?`;\n      params = [status, reviewedBy, now, rejectionReason, now, id];\n    } else {\n      return NextResponse.json({ error: '无效的状态' }, { status: 400 });\n    }\n    \n    const [result] = await connection.execute(query, params);\n    \n    if ((result as any).affectedRows === 0) {\n      await connection.end();\n      return NextResponse.json({ error: '文章不存在' }, { status: 404 });\n    }\n    \n    // 获取更新后的文章\n    const [updatedPostRows] = await connection.execute(\n      `SELECT \n        p.id, p.title, p.excerpt, p.content, p.image, p.readTime, \n        p.authorId, p.categoryId, p.status, p.foundSensitiveWords, p.reviewedBy, p.reviewedAt, p.rejectionReason, p.createdAt, p.updatedAt,\n        u.name as authorName, u.avatar as authorAvatar,\n        c.name as categoryName, c.slug as categorySlug\n      FROM post p\n      LEFT JOIN user u ON p.authorId = u.id\n      LEFT JOIN category c ON p.categoryId = c.id\n      WHERE p.id = ?`,\n      [id]\n    );\n    \n    await connection.end();\n    \n    const updatedPost = (updatedPostRows as any)[0];\n    \n    // 转换数据格式\n    const formattedPost = {\n      id: updatedPost.id,\n      title: updatedPost.title,\n      excerpt: updatedPost.excerpt,\n      content: updatedPost.content,\n      image: updatedPost.image,\n      readTime: updatedPost.readTime,\n      authorId: updatedPost.authorId,\n      categoryId: updatedPost.categoryId,\n      createdAt: updatedPost.createdAt,\n      updatedAt: updatedPost.updatedAt,\n      status: updatedPost.status as 'published' | 'pending' | 'rejected',\n      foundSensitiveWords: updatedPost.foundSensitiveWords ? JSON.parse(updatedPost.foundSensitiveWords) : [],\n      reviewedBy: updatedPost.reviewedBy,\n      reviewedAt: updatedPost.reviewedAt,\n      rejectionReason: updatedPost.rejectionReason,\n      likes: 0,\n      author: {\n        id: updatedPost.authorId,\n        name: updatedPost.authorName,\n        avatar: updatedPost.authorAvatar\n      },\n      category: {\n        id: updatedPost.categoryId,\n        name: updatedPost.categoryName,\n        slug: updatedPost.categorySlug\n      },\n      comments: []\n    };\n    \n    return NextResponse.json(formattedPost, { status: 200 });\n  } catch (error) {\n    console.error('更新文章状态失败:', error);\n    return NextResponse.json({ error: '更新文章状态失败' }, { status: 500 });\n  }\n}\n\n// 删除文章\nexport async function DELETE(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const postId = parseInt(searchParams.get('id') || '0');\n\n    if (!postId) {\n      return NextResponse.json({ error: 'Invalid post ID' }, { status: 400 });\n    }\n\n    const connection = await createConnection();\n    const [result] = await connection.execute('DELETE FROM post WHERE id = ?', [postId]);\n    await connection.end();\n    \n    if ((result as any).affectedRows === 0) {\n      return NextResponse.json({ error: 'Post not found' }, { status: 404 });\n    }\n\n    return NextResponse.json({ message: 'Post deleted successfully' }, { status: 200 });\n  } catch (error) {\n    console.error('删除文章失败:', error);\n    return NextResponse.json({ error: '删除文章失败' }, { status: 500 });\n  }\n}","// 违禁词列表\r\nconst sensitiveWords = [\r\n  '骚', '贱', '傻逼', '操', 'fuck', 'shit',\r\n  '政治敏感词1', '政治敏感词2', '色情敏感词1', '色情敏感词2'\r\n];\r\n\r\n/**\r\n * 检测文本中是否包含违禁词\r\n * @param text 待检测文本\r\n * @returns 包含违禁词的数组，如果没有则返回空数组\r\n */\r\nexport const detectSensitiveWords = (text: string): string[] => {\r\n  const foundWords: string[] = [];\r\n  \r\n  sensitiveWords.forEach(word => {\r\n    const regex = new RegExp(word, 'gi');\r\n    if (regex.test(text)) {\r\n      foundWords.push(word);\r\n    }\r\n  });\r\n  \r\n  return foundWords;\r\n};\r\n\r\n/**\r\n * 检查文本是否包含违禁词\r\n * @param text 待检测文本\r\n * @returns 是否包含违禁词\r\n */\r\nexport const hasSensitiveWords = (text: string): boolean => {\r\n  return detectSensitiveWords(text).length > 0;\r\n};\r\n\r\n/**\r\n * 过滤文本中的违禁词，用*替换\r\n * @param text 待过滤文本\r\n * @returns 过滤后的文本\r\n */\r\nexport const filterSensitiveWords = (text: string): string => {\n  let filteredText = text;\n  \n  sensitiveWords.forEach(word => {\n    const regex = new RegExp(word, 'gi');\n    filteredText = filteredText.replace(regex, '*'.repeat(word.length));\n  });\n  \n  return filteredText;\n};\n\n/**\n * 检测文本中的隐藏字符\n * @param text 待检测文本\n * @returns 隐藏字符的数量\n */\nexport const countHiddenCharacters = (text: string): number => {\n  // 匹配各种隐藏字符的正则表达式\n  // 包括：零宽度空格、零宽度非连接符、零宽度连接符、制表符、换行符、回车符、垂直制表符、换页符等\n  const hiddenCharRegex = /[\\u200B-\\u200D\\uFEFF\\t\\n\\r\\v\\f\\u0000-\\u001F\\u007F-\\u009F]/g;\n  const matches = text.match(hiddenCharRegex);\n  return matches ? matches.length : 0;\n};"],"names":[],"mappings":"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","ignoreList":[0]}