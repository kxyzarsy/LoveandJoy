{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///D:/MyBlog/LoveandJoy/src/lib/db-pool.ts"],"sourcesContent":["import mysql from 'mysql2/promise';\n\n// 数据库连接配置\nconst DB_CONFIG = {\n  host: 'localhost',\n  port: 3306,\n  user: 'root',\n  password: '123456',\n  database: 'yueblog',\n  // 连接池配置\n  connectionLimit: 10, // 最大连接数\n  queueLimit: 0, // 连接请求队列大小，0表示无限制\n  waitForConnections: true, // 当连接池无可用连接时，是否等待\n  acquireTimeout: 10000, // 获取连接的超时时间（毫秒）\n  connectTimeout: 10000, // 建立连接的超时时间（毫秒）\n  idleTimeout: 60000, // 连接空闲超时时间（毫秒）\n  enableKeepAlive: true, // 启用TCP KeepAlive\n  keepAliveInitialDelay: 30000 // TCP KeepAlive初始延迟（毫秒）\n};\n\n// 创建数据库连接池\nconst pool = mysql.createPool(DB_CONFIG);\n\n/**\n * 获取数据库连接\n * @returns Promise<mysql.PoolConnection> 数据库连接对象\n */\nexport const getConnection = async (): Promise<mysql.PoolConnection> => {\n  try {\n    const connection = await pool.getConnection();\n    return connection;\n  } catch (error) {\n    console.error('获取数据库连接失败:', error);\n    throw error;\n  }\n};\n\n/**\n * 释放数据库连接\n * @param connection 数据库连接对象\n */\nexport const releaseConnection = (connection: mysql.PoolConnection): void => {\n  try {\n    connection.release();\n  } catch (error) {\n    console.error('释放数据库连接失败:', error);\n  }\n};\n\n/**\n * 执行SQL查询（自动管理连接）\n * @param sql SQL查询语句\n * @param values 查询参数\n * @returns Promise<[any[], mysql.FieldPacket[]]> 查询结果\n */\nexport const executeQuery = async (sql: string, values?: any[]): Promise<[any[], mysql.FieldPacket[]]> => {\n  let connection: mysql.PoolConnection | null = null;\n  try {\n    connection = await getConnection();\n    const result = await connection.execute(sql, values);\n    return result;\n  } catch (error) {\n    console.error('执行SQL查询失败:', error);\n    throw error;\n  } finally {\n    if (connection) {\n      releaseConnection(connection);\n    }\n  }\n};\n\n/**\n * 执行事务操作\n * @param callback 事务回调函数，接收connection参数，返回Promise\n * @returns Promise<T> 事务执行结果\n */\nexport const executeTransaction = async <T>(callback: (connection: mysql.PoolConnection) => Promise<T>): Promise<T> => {\n  let connection: mysql.PoolConnection | null = null;\n  try {\n    connection = await getConnection();\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    if (connection) {\n      await connection.rollback();\n    }\n    console.error('执行事务失败:', error);\n    throw error;\n  } finally {\n    if (connection) {\n      releaseConnection(connection);\n    }\n  }\n};\n\n/**\n * 获取连接池状态\n * @returns Promise<{ size: number, used: number, free: number, pending: number }> 连接池状态\n */\nexport const getPoolStatus = async (): Promise<{ size: number; used: number; free: number; pending: number }> => {\n  try {\n    const poolStats = await pool.pool.promise().getConnection();\n    // @ts-ignore - mysql2/promise pool类型定义可能不包含这些属性\n    const status = {\n      size: poolStats.pool._poolSize,\n      used: poolStats.pool._allConnections.length - poolStats.pool._freeConnections.length,\n      free: poolStats.pool._freeConnections.length,\n      pending: poolStats.pool._connectionQueue.length\n    };\n    poolStats.release();\n    return status;\n  } catch (error) {\n    console.error('获取连接池状态失败:', error);\n    return {\n      size: 0,\n      used: 0,\n      free: 0,\n      pending: 0\n    };\n  }\n};\n\n/**\n * 关闭连接池\n */\nexport const closePool = async (): Promise<void> => {\n  try {\n    await pool.end();\n    console.log('数据库连接池已关闭');\n  } catch (error) {\n    console.error('关闭连接池失败:', error);\n    throw error;\n  }\n};\n\n// 导出连接池，方便直接使用\nexport default pool;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;AAEA,UAAU;AACV,MAAM,YAAY;IAChB,MAAM;IACN,MAAM;IACN,MAAM;IACN,UAAU;IACV,UAAU;IACV,QAAQ;IACR,iBAAiB;IACjB,YAAY;IACZ,oBAAoB;IACpB,gBAAgB;IAChB,gBAAgB;IAChB,aAAa;IACb,iBAAiB;IACjB,uBAAuB,MAAM,wBAAwB;AACvD;AAEA,WAAW;AACX,MAAM,OAAO,8IAAK,CAAC,UAAU,CAAC;AAMvB,MAAM,gBAAgB;IAC3B,IAAI;QACF,MAAM,aAAa,MAAM,KAAK,aAAa;QAC3C,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;QAC5B,MAAM;IACR;AACF;AAMO,MAAM,oBAAoB,CAAC;IAChC,IAAI;QACF,WAAW,OAAO;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;IAC9B;AACF;AAQO,MAAM,eAAe,OAAO,KAAa;IAC9C,IAAI,aAA0C;IAC9C,IAAI;QACF,aAAa,MAAM;QACnB,MAAM,SAAS,MAAM,WAAW,OAAO,CAAC,KAAK;QAC7C,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;QAC5B,MAAM;IACR,SAAU;QACR,IAAI,YAAY;YACd,kBAAkB;QACpB;IACF;AACF;AAOO,MAAM,qBAAqB,OAAU;IAC1C,IAAI,aAA0C;IAC9C,IAAI;QACF,aAAa,MAAM;QACnB,MAAM,WAAW,gBAAgB;QACjC,MAAM,SAAS,MAAM,SAAS;QAC9B,MAAM,WAAW,MAAM;QACvB,OAAO;IACT,EAAE,OAAO,OAAO;QACd,IAAI,YAAY;YACd,MAAM,WAAW,QAAQ;QAC3B;QACA,QAAQ,KAAK,CAAC,WAAW;QACzB,MAAM;IACR,SAAU;QACR,IAAI,YAAY;YACd,kBAAkB;QACpB;IACF;AACF;AAMO,MAAM,gBAAgB;IAC3B,IAAI;QACF,MAAM,YAAY,MAAM,KAAK,IAAI,CAAC,OAAO,GAAG,aAAa;QACzD,gDAAgD;QAChD,MAAM,SAAS;YACb,MAAM,UAAU,IAAI,CAAC,SAAS;YAC9B,MAAM,UAAU,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,UAAU,IAAI,CAAC,gBAAgB,CAAC,MAAM;YACpF,MAAM,UAAU,IAAI,CAAC,gBAAgB,CAAC,MAAM;YAC5C,SAAS,UAAU,IAAI,CAAC,gBAAgB,CAAC,MAAM;QACjD;QACA,UAAU,OAAO;QACjB,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;QAC5B,OAAO;YACL,MAAM;YACN,MAAM;YACN,MAAM;YACN,SAAS;QACX;IACF;AACF;AAKO,MAAM,YAAY;IACvB,IAAI;QACF,MAAM,KAAK,GAAG;QACd,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,YAAY;QAC1B,MAAM;IACR;AACF;uCAGe"}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///D:/MyBlog/LoveandJoy/src/app/api/users/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport bcrypt from 'bcrypt';\nimport { executeQuery } from '@/lib/db-pool';\n\n// 获取所有用户\nexport async function GET() {\n  try {\n    const [rows] = await executeQuery('SELECT id, name, email, usernameId, avatar, backgroundImage, bio, role, inactive, createdAt, updatedAt FROM user');\n    \n    // 计算每个用户的剩余用户名修改时间\n    const usersWithRemainingTime = (rows as any[]).map(user => {\n      let remainingHours = 0;\n      if (user.lastUsernameChange) {\n        const lastChangeTime = new Date(user.lastUsernameChange);\n        const now = new Date();\n        const diffHours = (now.getTime() - lastChangeTime.getTime()) / (1000 * 60 * 60);\n        remainingHours = Math.max(0, Math.ceil(720 - diffHours));\n      }\n      return {\n        ...user,\n        remainingUsernameChangeHours: remainingHours\n      };\n    });\n    \n    return NextResponse.json(usersWithRemainingTime, { status: 200 });\n  } catch (error) {\n    console.error('获取用户数据失败:', error);\n    return NextResponse.json({ error: '获取用户数据失败' }, { status: 500 });\n  }\n}\n\n// 添加新用户\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { name, email, password, usernameId, avatar, bio, role } = body;\n    \n    // 检查用户名ID是否已存在\n    const [existingUserRows] = await executeQuery(\n      'SELECT id FROM user WHERE usernameId = ?',\n      [usernameId]\n    );\n    \n    if ((existingUserRows as any).length > 0) {\n      return NextResponse.json({\n        error: '用户名ID已存在',\n        message: '该用户名ID已被其他用户使用，请选择其他ID'\n      }, { status: 400 });\n    }\n    \n    // 检查必填字段\n    if (!name || !email || !password || !usernameId) {\n      return NextResponse.json({ \n        error: '缺少必填字段',\n        message: 'name, email, password和usernameId是必填字段'\n      }, { status: 400 });\n    }\n    \n    // 加密密码\n    const hashedPassword = await bcrypt.hash(password, 10);\n    \n    const [result] = await executeQuery(\n      'INSERT INTO user (name, email, password, usernameId, avatar, bio, role, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())',\n      [name, email, hashedPassword, usernameId, avatar || null, bio || null, role || 'user']\n    );\n    \n    const [newUser] = await executeQuery(\n      'SELECT id, name, email, usernameId, avatar, backgroundImage, bio, role, inactive, createdAt, updatedAt FROM user WHERE id = ?',\n      [(result as any).insertId]\n    );\n    \n    const createdUser = (newUser as any)[0];\n    return NextResponse.json({\n      ...createdUser,\n      remainingUsernameChangeHours: 0 // 新用户可以立即修改用户名ID\n    }, { status: 201 });\n  } catch (error) {\n    console.error('添加用户失败:', error);\n    return NextResponse.json({ error: '添加用户失败', details: (error as Error).message }, { status: 500 });\n  }\n}"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,CAAC,KAAK,GAAG,MAAM,IAAA,0IAAY,EAAC;QAElC,mBAAmB;QACnB,MAAM,yBAAyB,AAAC,KAAe,GAAG,CAAC,CAAA;YACjD,IAAI,iBAAiB;YACrB,IAAI,KAAK,kBAAkB,EAAE;gBAC3B,MAAM,iBAAiB,IAAI,KAAK,KAAK,kBAAkB;gBACvD,MAAM,MAAM,IAAI;gBAChB,MAAM,YAAY,CAAC,IAAI,OAAO,KAAK,eAAe,OAAO,EAAE,IAAI,CAAC,OAAO,KAAK,EAAE;gBAC9E,iBAAiB,KAAK,GAAG,CAAC,GAAG,KAAK,IAAI,CAAC,MAAM;YAC/C;YACA,OAAO;gBACL,GAAG,IAAI;gBACP,8BAA8B;YAChC;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC,wBAAwB;YAAE,QAAQ;QAAI;IACjE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,aAAa;QAC3B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAW,GAAG;YAAE,QAAQ;QAAI;IAChE;AACF;AAGO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;QAEjE,eAAe;QACf,MAAM,CAAC,iBAAiB,GAAG,MAAM,IAAA,0IAAY,EAC3C,4CACA;YAAC;SAAW;QAGd,IAAI,AAAC,iBAAyB,MAAM,GAAG,GAAG;YACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,OAAO;gBACP,SAAS;YACX,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,SAAS;QACT,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC,YAAY;YAC/C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,OAAO;gBACP,SAAS;YACX,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,OAAO;QACP,MAAM,iBAAiB,MAAM,gHAAM,CAAC,IAAI,CAAC,UAAU;QAEnD,MAAM,CAAC,OAAO,GAAG,MAAM,IAAA,0IAAY,EACjC,4IACA;YAAC;YAAM;YAAO;YAAgB;YAAY,UAAU;YAAM,OAAO;YAAM,QAAQ;SAAO;QAGxF,MAAM,CAAC,QAAQ,GAAG,MAAM,IAAA,0IAAY,EAClC,iIACA;YAAE,OAAe,QAAQ;SAAC;QAG5B,MAAM,cAAc,AAAC,OAAe,CAAC,EAAE;QACvC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,GAAG,WAAW;YACd,8BAA8B,EAAE,iBAAiB;QACnD,GAAG;YAAE,QAAQ;QAAI;IACnB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,WAAW;QACzB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAAU,SAAS,AAAC,MAAgB,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IACjG;AACF"}}]
}